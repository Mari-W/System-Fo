\subsection{Specification}
\subsubsection{Sorts}\hfill\\\\
The formalization of System F requires three sorts: \Constr{eₛ} for expressions, \Constr{τₛ} for types and \Constr{κₛ} for kinds. 
\FSort
Sorts are indexed by the boolean data type \Data{Ctxable}. 
The index \Constr{⊤ᶜ} indicates that variables for terms of sort \Sym{s} can be bound. 
In contrast, \Constr{⊥ᶜ} says that variables for terms of sort \Sym{s} cannot be bound. 
In this case, System F supports abstracting over expressions and types, but not over kinds. 
Going forward, we also use the variable name \Sym{S} for lists of contextable sorts that have type \FSorts.

\subsubsection{Syntax}\hfill\\\\
The syntax of System F is represented in a single data type \Data{Term}, indexed by sorts \Sym{S} and sort \Sym{s}. 
The index \Sym{S} is inspired by Debruijn indices. Debruijn indices reference variables using a number that counts the amount of binders that are in scope between the binding of the variable and the position it is used at.
In Agda, terms are often indexed by the amount of bound variables. The variable constructor then only accepts Debruijn indices that are smaller or equal to the current amount of bound variables. 
Thus, unbound variables cannot be referenced by definition.
But indexing \Data{Term} with a number is not sufficient because System F has both expression variables and type variables that need to be distinguished. 
To solve this problem, we need to extend the idea of Debruijn indices and store the corresponding sort for each variable. Thus, we let \Sym{S} be a list of sorts instead of a number.
The length of \Sym{S} represents the amount of bound variables and the elements \Sym{s$_i$} of the list represent the sort of the variable bound at that debruijn index. 
The index \Sym{s} represents the sort of the term itself.
\FTerm
Variables \Constr{`}\ \Sym{x} are represented as membership proofs \Sym{s} \Prim{∈} \Sym{S}. In consequence, we can only reference already bound variables.
Membership proofs of type \Sym{s} \Prim{∈} \Sym{S} are inductively defined, similar to natural numbers. 
Membership proofs can be constructed using the constructor \Constr{here refl}, where \Constr{refl} is proof that the last element in \Sym{S} is the element we searched for. Alternatively, membership proofs can be constructed via the constructor \Constr{there} \Sym{x}, where \Sym{x} is another membership proof for \Sym{S} with one element less. 

\noindent The unit element \Constr{tt} and unit type \Constr{`⊤} represent base expressions and types respectively. 

\noindent Lambda abstractions \Constr{λ`x→} \Sym{e'} result in function types \Sym{τ₁} \Constr{⇒} \Sym{τ₂} and type abstractions \Constr{Λ`α→} \Sym{e'} result in forall types \Constr{∀`α} \Sym{τ'}. 
Both bindings introduce an additional sort \Constr{eₛ}, or \Constr{τₛ} respectively, to the index \Sym{S} of the body \Sym{e'}.

\noindent The application constructor \Sym{e₁} \Constr{·} \Sym{e₂} applies the argument \Sym{e₂} to the function \Sym{e₁}.

\noindent Similarly, type application \Sym{e} \Constr{•} \Sym{τ} eliminates type abstractions. 

\noindent Let bindings \Constr{let`x=} \Sym{e₂} \Constr{`in} \Sym{e₁} combine abstraction and application. 

\noindent All types \Sym{τ} have kind \Constr{⋆}.

\noindent We use abbreviations \FVar, \FExpr, \FType\ and variable names \Sym{x}, \Sym{e} and \Sym{τ} respectively. Furthermore, we use the variable \Sym{t} for an arbitrary \Data{Term} \Sym{S} \Sym{s}.

\subsubsection{Renaming}\hfill\\\\
Renamings \Sym{ρ} of type \Data{Ren} \Sym{S₁} \Sym{S₂} are defined as total functions mapping variables \Data{Var} \Sym{S₁} \Sym{s} to variables \Data{Var} \Sym{S₂} \Sym{s}. 
Renamings preserve the sort \Sym{s} of the variable.
\FRen
Applying a renaming \Data{Ren} \Sym{S₁} \Sym{S₂} to a term \Data{Term} \Sym{S₁} \Sym{s} yields a new term \Data{Term} \Sym{S₂} \Sym{s}, where variables are now represented as references to elements in \Sym{S₂}.
\Fren
The renaming is applied to all variables \Sym{x}.

\noindent When we encounter a binder for a term of sort \Sym{s}, the renaming is extended using \Frenext. 

\noindent The weakening of a term can be defined as shifting all variables by one.
\Fwk 
Because variables are represented as membership proofs, shifting variables by one binder is accomplished by wrapping them in the \Constr{there} constructor.

\subsubsection{Substitution}\hfill\\\\
Substitutions \Sym{σ} of type \Data{Sub} \Sym{S₁} \Sym{S₂} are similar to renamings, but rather than mapping variables to variables, substitutions map variables to terms.
\FSub
Applying a substitution using the \Data{sub} function is analogous to applying a renaming using \Data{ren}. If we encounter a binder in \Data{sub}, the substitution must be extended using function \Data{extₛ}.
\Fext
The extension of a substitution is defined as the weakening of all terms that result in the substitution being applied to variables \Sym{x}.

\noindent The substitution operator \Sym{t} \Data{[} \Sym{t'} \Data{]} substitutes the last bound variable in \Sym{t} with \Sym{t'}.
\Fsubs
A single substitution \Fsinglesub\ takes an existing substitution \Sym{σ'} and substitutes \Sym{t'} for an additional new binding. In the case of \Data{\_[\_]}, we let \Sym{σ'} be the identity substitution \Fidsub.

\subsubsection{Context}\hfill\\\\
Similar to terms, typing contexts \Sym{Γ} of type \Data{Ctx} \Sym{S} are also indexed by the list of bound variables. In consequence, only types and kinds for bound variables can be stored in \Sym{Γ} by definition.
\FCtx
Contexts are inductively defined and can either be empty \Constr{∅} or extended with one element \Sym{T}, using the constructor \Sym{Γ} \Constr{▶} \Sym{T}. The variable \Sym{T} represents terms of the sort \Data{kind-of} \Sym{s}. 
\noindent The function \Data{kind-of} maps contextable sorts \Sym{s} to the sort of the term that is stored in \Sym{Γ} for variables with the sort \Sym{s}.
\Fkind
Expression variables require \Sym{Γ} to store the corresponding type. 
For type variables, \Sym{Γ} stores the corresponding kind. Thus, if we bind a new variable for a term of the sort \Sym{s}, the context \Sym{Γ} is extended by a term of the sort \Data{kind-of} \Sym{s}.

\noindent The \Data{lookup} function resolves the type or kind for a variable \Sym{x} in \Sym{Γ}.
\Flookup
Both the base and induction case wrap the looked up constraint in a weakening. Thus, the looked up \Sym{T} has index \Sym{S} that aligns with the current amount of bound variables. The \Data{lookup} function cannot fail by definition because we only allow to lookup bound variables that must have an entry in \Sym{Γ}.

\subsubsection{Typing}\hfill\\\\
The typing relation \Sym{Γ} \Data{⊢} \Sym{t} \Data{:} \Sym{T} relates terms \Sym{t} to their typing result \Sym{T} in a context \Sym{Γ}.
\FTyping
The rule \Constr{⊢`x} says that a variable \Constr{`} \Sym{x} has type \Sym{τ}, if the looked up type for \Sym{x} in \Sym{Γ} is \Sym{τ}. 

\noindent All unit expressions \Constr{tt} have the type \Constr{`⊤}. This is expressed by the rule \Sym{⊢⊤}.

\noindent The rule for abstractions \Constr{⊢λ} introduces an expression variable of type \Sym{τ} to the body \Sym{e}. 
Because the body type \Sym{τ'} cannot use the newly introduced expression variable, we let \Sym{τ'} have one variable bound less and weaken it to align with the context \Sym{Γ} \Constr{▶} \Sym{τ}. 
Hence, \Sym{τ'} aligns with \Sym{τ} in the list of bound variables to form the resulting function type \Sym{τ} \Constr{⇒} \Sym{τ’}. 

\noindent The type abstraction rule \Constr{⊢Λ} introduces a type of kind \Constr{⋆} to the body \Sym{e} and results in the forall type \Constr{∀`α} \Sym{τ}, where \Sym{τ} is the type of \Sym{e}. 

\noindent Application is handled by the rule \Constr{⊢·} and says that if \Sym{e₁} is a function from \Sym{τ₁} to \Sym{τ₂} and \Sym{e₂} has type \Sym{τ₁}, then \Sym{e₁} \Constr{·} \Sym{e₂} has type \Sym{τ₂}. 

\noindent Similarly, the type application rule \Constr{⊢•} states that if \Sym{e} has type \Constr{∀`α} \Sym{τ}, then \Sym{α} can be substituted with another type \Sym{τ'} in \Sym{τ}. 

\noindent The rule \Constr{⊢let} combines the abstraction and application rule.

\noindent For the typing of types, the rule \Constr{⊢τ} indicates that all types \Sym{τ} are well formed and have kind \Constr{⋆}. Type variables are correctly typed per definition and type constructors \Constr{∀`α} and \Constr{⇒} accept arbitrary types as their arguments.

\subsubsection{Typing of Renaming \& Substitution}\hfill\\\\
Because of extrinsic typing, both renamings and substitutions need to have typed counterparts.
We formalize typed renamings \Sym{⊢ρ} as order preserving embeddings. 
Thus, if a variable \Sym{x₁} of type \Sym{s₁} \Data{∈} \Sym{S₁} references an element with an index smaller than some other variable \Sym{x₂} in \Sym{S₁}, then renamed \Sym{x₁} must still reference an element with a smaller index than renamed \Sym{x₂} in \Sym{S₂}.
Arbitrary renamings would allow swapping types in the context and thus potentially violate the telescoping. 
Telescoping allows types in the context to depend on type variables bound before them.
\FRenTyping
The identity renaming \Constr{⊢idᵣ} is typed by definition. 

\noindent The extension of a renaming \Constr{⊢extᵣ} allows to extend both \Sym{Γ₁} and \Sym{Γ₂} by \Sym{T'} and renamed \Sym{T'} respectively. The constructor \Constr{⊢extᵣ} corresponds to the typed version of the function \Data{extᵣ} that is used when a binder is encountered. 

\noindent The constructor \Constr{⊢dropᵣ} allows to introduce \Sym{T'} only in \Sym{Γ₂}. 
Hence, \Constr{⊢dropᵣ ⊢idᵣ} corresponds to the typed weakening of a term.

\noindent Typed Substitutions are defined as total functions, similar to untyped substitutions.
\FSubTyping
Typed substitutions \Sym{⊢σ} map variables \Sym{x} \Constr{∈} \Sym{S₁} to the corresponding typing of \Sym{σ x} in \Sym{Γ₂}. The typing result of \Sym{σ x} is the original type of \Sym{x} in \Sym{Γ₁} applied to \Sym{σ}.
\subsubsection{Semantics}\hfill\\\\
The semantics are formalized as call-by-value. That is, there is no reduction under binders. Values are indexed by their corresponding irreducible expression.
\FVal
System F has three values. The two closure values \Constr{v-λ} and \Constr{v-Λ} and the unit value \Constr{v-tt}.
We formalize small step semantics where each constructor represents a single reduction step \Sym{e} \Constr{↪} \Sym{e'}.
We distinguish between \Sym{β} and \Sym{ξ} rules. 
Meaningful computation in the form of substitution is done by \Sym{β} rules while \Sym{ξ} rules only reduce sub expressions.
\FSemantics
The rules \Constr{β-λ} and \Constr{β-Λ} give meaning to application and type application by substituting the applied expression, or type respectively, into the abstraction body. 

\noindent Reductions \Constr{β-let} are equivalent to \Constr{β-λ} and substitute \Sym{e₂} into \Sym{e₁}. 

\noindent The rules \Constr{ξ-·$_i$} and \Constr{ξ-•} evaluate sub expressions of applications until \Sym{e₁} and \Sym{e₂}, or \Sym{e} respectively, are values. 

\noindent The rule \Constr{ξ-let} reduces the bound expression \Sym{e₂} until \Sym{e₂} is a value and \Constr{β-let} can be applied. 

\subsection{Soundness}

\subsubsection{Progress}\hfill\\\\
We prove progress, that is, a typed expression \Sym{e} can either be further reduced to some \Sym{e'} or \Sym{e} is a value. The proof follows by induction over the typing rules. 
\FProgress
The cases \Constr{⊢⊤}, \Constr{⊢λ} and \Constr{⊢Λ} result in values. 
The application cases \Constr{⊢·}, \Constr{⊢•} and \Constr{⊢let} follow directly from the induction hypothesis. 
\subsubsection{Subject Reduction}\hfill\\\\
We prove subject reduction, that is, reduction preserves typing. More specifically, an expression \Sym{e} with type \Sym{τ} still has type \Sym{τ} after being reduced to \Sym{e'}. We prove subject reduction by induction over the reduction rules. 
\FSubjectReduction
The \Sym{ξ} reduction cases \Constr{ξ-·₁}, \Constr{ξ-·₂}, \Constr{ξ-•} and \Constr{ξ-let} follow directly from the induction hypothesis. 

\noindent For the \Sym{β} reduction cases \Constr{β-λ}, \Constr{β–Λ} and \Constr{β-let} we need to prove that substitutions preserve typing. We have two cases for substitutions in reduction rules: \Sym{e} \Data{[} \Sym{e} \Data{]} and \Sym{e} \Data{[} \Sym{τ} \Data{]}.
Both \Data{e[e]-preserves} and \Data{e[τ]-preserves} follow from a more general lemma \Data{⊢σ-preserves}. 
\Fpreserves
The lemma \Data{⊢σ-preserves} follows by induction over the typing rules and lemmas about the interaction between renamings and substitutions. 

\noindent The soundness property of System F follows as a consequence of \Data{progress} and \Data{subject-reduction}. 