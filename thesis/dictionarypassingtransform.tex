\subsection{Translation}
\subsubsection{Sorts}\hfill\\\\
The translation of System \Fo\ sorts to System F sorts only considers sorts that are contextable. The two missing non-contextable sorts \Constr{cₛ} and \Constr{κₛ} do not need to be translated for our purpose. Intuitively there does not even exist a sensible translation for \Constr{cₛ}.
\DPTSort
Sort \Constr{eₛ} and \Constr{τₛ} translate to their corresponding counterparts in System F. Overloaded variables in System \Fo\ are translate to normal variables in System F. Thus sort \Constr{oₛ} translates to \Constr{eₛ}. 

\noindent Translating lists \Sym{S} directly is not possible, because there might appear additional sorts inside the list after the translation. 
New sorts must be added for variable bindings introduced by the translation. 
For example, a \Constr{inst`} \Constr{`} \Sym{o} \Constr{=} \Sym{e₂} \Constr{`in} \Sym{e₁} expression does not bind a new variable in \Sym{e₁}, but translates to a \Constr{let`x=} \Sym{e₂} \Constr{`in} \Sym{e₁} binding. 
Hence \Sym{S} must have a new entry \Constr{eₛ} at the corresponding position to further function as valid index for the translated \Sym{e₁}. 
To solve this problem the System \Fo\ context \Sym{Γ} is used to build the translated \Sym{S}. 
The context stores the relevant information about introduced constraints and thus where new bindings will occur, that were not present in System \Fo. 

\DPTSorts
The empty context \Constr{∅} corresponds to the empty list \Constr{[]}.
For each constraint in \Sym{Γ} an additional sort \Constr{eₛ} is appended to \Sym{S}, representing the new binder introduced by the translation. If we find that a normal item is stored in the context, \Sym{s} is directly translated to \Data{s⇝s} \Sym{s}.

\subsection{Variables}\hfill\\\\
Similar to lists \Sym{S}, the translation for variables \Sym{x} needs context information.  
\DPTVar
If an item is stored in the context we can translate the variable directly. 
Whenever a constraint is encountered, \Sym{x} is wrapped in an additional \Constr{there}. This is because, the expression that introduced the constraint will translate to an expression with an additional new binding, that needs to be respected in System F.

\noindent Furthermore, resolved constraints translate to the correct unique expression variable. 
\DPTOVar
The idea is the same as before, we wrap the variable in an additional \Constr{there}, for each constraint in the context.

\subsubsection{Context}\hfill\\\\
The translation of contexts is mostly a direct translation. We only look at the translation of constraints stored in the context.
\DPTCtx
Following the idea from above, constraints \Sym{o} \Constr{:} \Sym{τ} stored inside \Sym{Γ} translate to normal items in the translated \Sym{Γ}. The item introduced is the translated type \Data{τ⇝τ} \Sym{τ} required by the constraint. Again, whenever we pick up a constraint in System \Fo\, there will be a new expression binding in System F, that accepts the constraint as higher order function. Thus, the corresponding type for that binding is expected in \Sym{Γ} at that position.

\subsubsection{Renaming \& Substitution}\hfill\\\\
Typed renamings in System \Fo\ get translated to untyped renamings in System F.
\DPTRen
Typed renamings \Constr{⊢idᵣ}, \Constr{⊢extᵣ} and \Constr{⊢dropᵣ} translate to their untyped counterparts. Because constraints in contexts translate to actual bindings, both \Constr{⊢ext-cstrᵣ} and \Constr{⊢drop-cstrᵣ} translate to normal \Constr{⊢extᵣ} and \Constr{⊢dropᵣ} in System F.

\noindent The translation of typed substitutions to untyped substitutions follows the same idea.

\DPTSub 

Cases \Constr{⊢idₛ}, \Constr{⊢extₛ}, \Constr{⊢dropₛ}, \Constr{⊢ext-cstrₛ} and \Constr{⊢drop-cstrₛ} are analogous to the cases for renamings. The typed introduction of a type \Constr{⊢typeₛ} translated to the untyped introduction of a term \Data{singleₛ}.

\subsubsection{Terms}\hfill\\\\
Types and kinds can be translated without typing information. Kind \Constr{⋆} translates to direct counterpart in System F. 
Furthermore, all System \Fo\ types translate to their direct counterparts in System F, except the constraint type \Constr{[} \Sym{o} \Constr{:} \Sym{τ} \Constr{]⇒} \Sym{τ'}.
\DPTType
Constraint types  \Constr{[} \Sym{o} \Constr{:} \Sym{τ} \Constr{]⇒} \Sym{τ'} translate to function types \Sym{τ} \Constr{⇒} \Sym{τ'}. 
The translation from constraint types to function types corresponds directly to the translation of constraint abstractions to normal abstractions. The implicitly resolved constraint will now be taken as higher order function argument.

\noindent Arbitrary terms can only be translated using typing information. The typing carries information about the instances that were resolved, for all usages of overloaded variables. The unique variable name for the resolved instance can then be substituted for the overloaded variable. We only look at the translation of System \Fo\ expressions that do not have a direct counterpart in System F.
\DPTTerms
Typed overloaded variables \Constr{⊢`o} carry information about the instance that was resolved for \Sym{o}.
We translate the resolved instance to the unique variable in System F, that points to the former instance, now let binding. 
Constraint abstractions translate to normal abstractions. 
An implicitly resolved constraint translates to a explicit application, that passes the resolved instance as argument. The \Constr{decl} expressions could be translated to nothing, as seen in the example at the beginning. Instead \Constr{decl} expressions are translated to useless let bindings, binding a unit value.
Because \Constr{decl} expressions bind a new overloaded variable in System \Fo, removing them would result in a variable binding less in System F and hence, more complex proofs.
As already discussed, \Constr{inst} expressions translate to \Constr{let} bindings.

\subsection{Type Preservation}
\subsubsection{Terms}\hfill\\\\
\DPTTermPres
\subsubsection{Variables}\hfill\\\\
\DPTVarPresLookup
\DPTOVarPresLookup
\subsubsection{Renaming}\hfill\\\\
\DPTVarPresRen
\DPTTypePresRen
\DPTTypePresWk
\DPTTypePresWkInst
\subsubsection{Substitution}\hfill\\\\
\DPTVarPresSub
\DPTTypePresSub
\DPTTypePresSingleSub