\subsection{Hindley Milner with Overloading}
In this scenario our source language for the Dictionary Passing Transform would be an extended Hindley Milner based system (\HMo) and our target language would be Hindley Milner (HM). 
HM is a restricted form of System F. HM would have two sorts \Constr{mₛ} for mono types and \Constr{pₛ} for poly types in favour of arbitrary types \Constr{τₛ}. Poly types can include quantification over type variables, while mono types consist only of primitive types and type variables. 
Usually all language constructs are restricted to mono types, except let bound variables. 
Hence polymorphism in HM is also called let polymorphism [CITE].  
In consequence, constraint abstractions would only allow to introduce constraints for overloaded variables with mono types. 
Furthermore, we need to restrict all instances for a overloaded variable \Sym{o} to differ in the type of their first argument.
With these two restrictions, type inference, using an extended version of Algorithm W, should be preserved [CITE]. Formalizing the changes and restrictions mentioned above should be a fairly straight forward adjustment to the formalization of System F and System \Fo.

\subsection{Semantic Preservation of System \Fo}
For now System \Fo\ does not have semantics formalized.
Semantics for System \Fo\ would need to be typed semantics, because applications \Constr{`} \Sym{o} \Constr{·} \Sym{e₁} $..$ \Constr{·} \Sym{e$_n$} need type information to reduce properly.
The correct instance for \Sym{o} needs to be resolved based on the types of arguments \Sym{e₁} $..$ \Sym{e$_n$}. 
More specifically, to formalize small step semantics we would need to apply the restriction mentioned above, that all instances for the same overloaded variable \Sym{o} must differ in the type of their first argument. 
In consequence, the resolved instance for single application step \Constr{`} \Sym{o} \Constr{·} \Sym{e} would be decidable.
Let \Sym{⊢e} \Data{↪} \Sym{⊢e'} be such a typed small step semantic for System \Fo. We would need to prove something similar to: If \Sym{⊢e} \Data{↪} \Sym{⊢e'} then \Constr{∃} \Constr{[} \Sym{e''} \Constr{]} (\Data{⊢e↪e'⇝e↪e'} \Sym{⊢e} \Data{↪*} \Sym{e''}) \Constr{×} (\Data{⊢e↪e'⇝e↪e'} \Sym{⊢e'} \Data{↪*} \Sym{e''}), where \Data{⊢e↪e'⇝e↪e'} translates typed System \Fo\ reductions to a untyped System F reductions.
Instead of translating reduction steps directly, we prove that both translated \Sym{⊢e} and \Sym{⊢e'} reduce to some System F expression \Sym{e''} using finite many reduction steps.
This more general formulation is needed because there might be more reduction steps in the translated System F expression than in the System \Fo\ expression. 
For example, an implicitly resolved constraint in System \Fo\ needs to be explicitly passed using a additional application step in System F. For now it is unclear, if semantic preservation can be shown using induction over the semantic rules or if logical relations are needed.

\subsection{Conclusion}
We have formalized both System F and System \Fo\ in Agda. 
System \Fo\ acts as core calculus, capturing the essence of overloading.
Using Agda we formalized the Dictionary Passing Transform between System F and System \Fo\. 
We proved System F to be sound and the Dictionary Passing Transform to be type preserving.